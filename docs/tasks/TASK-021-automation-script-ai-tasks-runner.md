# TASK-021: Скрипт автоматизации выполнения заданий AI-агентом

**Статус**: ✅ Выполнено  
**Ветка**: `feature/TASK-021-automation-script-ai-tasks-runner`

---

## Донастройка пользователем (чтобы скрипт стал полноценно работающим)

Реализованный скрипт по умолчанию использует **заглушки** агентов (exec, verify, actualize). Чтобы скрипт стал полноценно работающим, пользователю нужно донастроить следующее:

1. **Агент выполнения (exec)** — заменить заглушку на реальный запуск агента Cursor (или другого AI-агента), который по описанию из файла задачи выполняет задание. Варианты:
   - Настроить в конфиге `scripts/ai-tasks-runner/config.default.json` поля `execAgent.command` и `execAgent.args` (или свой конфиг и передать его через `--config` / `AI_TASKS_CONFIG`).
   - Либо задать переменную окружения `AI_TASKS_EXEC_CMD` — команда и аргументы одной строкой (например, вызов Cursor CLI/API с плейсхолдерами `{{TASK_PATH}}`, `{{ATTEMPT}}`, если поддерживается).
   - Для ночного/автономного запуска нужен способ вызова агента **без интерактивного ввода** (headless, CLI, API).

2. **Агент проверки (verify)** — заменить заглушку на реализацию, которая проверяет выполнение задания и:
   - возвращает код выхода 0 при успехе, не 0 при неуспехе;
   - при неуспехе записывает в **конец документа задачи** блок проверки: дата/время, номер попытки, статус (успех/неуспех), перечень доработок (формат — см. раздел «Проверка и доработки в документе задачи» ниже).

   Настройка: конфиг `verifyAgent` или переменная `AI_TASKS_VERIFY_CMD`.

3. **Агент актуализации (actualize)** — заменить заглушку на реализацию, которая после успешной проверки обновляет:
   - документ задачи (например, статус «Выполнено», дата завершения);
   - манифест `docs/tasks/tasks-manifest.json`: для данной задачи поля `status`, `completedDate`, `branch`.

   Настройка: конфиг `actualizeAgent` или переменная `AI_TASKS_ACTUALIZE_CMD`.

4. **Git и окружение** (для автономного/ночного запуска):
   - Убедиться, что push выполняется без запроса пароля (SSH-ключ, токен в URL, credential helper).
   - При необходимости задать в конфиге `baseBranch`, `remote`, путь к манифесту и папке логов (если отличаются от значений по умолчанию).

5. **Опционально:** таймауты на попытки (если в конфиге/коде предусмотрены поля вроде `execTimeoutMs`, `verifyTimeoutMs`), режим dry-run (`--dry-run`) для проверки списка задач без запуска агентов.

Подробности по конфигу, аргументам и переменным окружения — в `scripts/ai-tasks-runner/README.md`.

---

## Главная цель

Выстроить **систему, способную работать автономно** и решать заранее составленные задачи без участия человека. Скрипт запускается по расписанию (например, ночью), по очереди обрабатывает задачи из манифеста, запуская агента выполнения (агент IDE **Cursor**), затем агента проверки и при успехе — агента актуализации. Всё выполняется без интерактивного ввода; результаты фиксируются в репозитории (коммиты, push) и в логах.

---

## Краткое описание

Создать скрипт, который по очереди выполняет задания из **docs/tasks/tasks-manifest.json**, запуская на каждое задание **агента выполнения (агент IDE Cursor)** и после каждой попытки — агента проверки. Для каждого задания: отдельная ветка, до 5 попыток, после каждой попытки — проверка, запись статуса и доработок в документ задачи, коммит. Логи работы агентов сохраняются в **docs/logs/**; имя файла: **название задания** → **дата** → **шаг** → **агент** → `-log.md`. При успешной проверке **перед переходом к следующему заданию** запускается агент актуализации, который обновляет состояние задачи и манифеста; после него — коммит, затем переход к следующему заданию. При неудаче за 5 попыток — остановка скрипта. **По завершении работы над заданием** (успешное или нет) выполняется **push** текущей ветки в удалённый репозиторий.

---

## Цели

1. **Последовательное выполнение заданий** — скрипт читает `docs/tasks/tasks-manifest.json` и обрабатывает задачи по порядку (по полю `id` или порядку в массиве).
2. **Запуск агента выполнения** — для каждой задачи скрипт запускает **агента выполнения — агент IDE Cursor** (Cursor agent), который выполняет задание по описанию из файла задачи. Агенты проверки и актуализации могут быть реализованы через тот же Cursor или отдельный интерфейс (см. конфигурацию).
3. **До 5 попыток на задание** — если проверка не прошла, агент выполнения запускается повторно (с учётом записанных доработок); не более 5 попыток на одну задачу.
4. **Агент проверки** — после каждой попытки выполнения запускается отдельный «агент проверки», который проверяет выполнение задания и по результату проверки записывает в конец документа задачи: статус проверки (успех/неуспех) и перечень необходимых доработок и исправлений.
5. **Агент актуализации** — перед переходом к следующему заданию запускается агент, который актуализирует состояние задачи (документ задачи) и манифеста (например: статус → completed, completedDate, branch). После работы агента актуализации выполняется коммит.
6. **Переход к следующему заданию** — после успешной проверки и работы агента актуализации (и коммита) скрипт переходит к следующему заданию из манифеста.
7. **Остановка при неудаче** — если за 5 попыток задание так и не решено, скрипт останавливается (следующие задания не запускаются). **При остановке в лог записывается подробная причина остановки** (id задачи, что задание не решено за 5 попыток, сводка по попыткам и т.п.).
8. **Push по завершении задания** — по завершении работы над заданием (успешное выполнение и актуализация или неудача за 5 попыток) выполняется **push** текущей ветки в удалённый репозиторий; затем переход к следующему заданию или выход.

---

## Обязательные требования

### Ветки и коммиты

- **Каждое задание выполняется в отдельной ветке.** Имя ветки задаётся по заданию (например, из поля `branch` в манифесте или по шаблону `feature/{id}-{slug}`). Ветка создаётся перед первой попыткой по задаче.
- **После работы каждого агента делается коммит:** после каждого запуска агента выполнения, агента проверки и агента актуализации должен выполняться коммит (сохранять изменения репозитория после шага).
- **По завершении работы над заданием делается push:** после завершения задания (успешная проверка + агент актуализации + коммит или неудача за 5 попыток + запись причины остановки в лог) выполняется **push** текущей ветки в удалённый репозиторий; затем скрипт переходит к следующему заданию или останавливается.

### Логирование

- **Действие каждого агента логируется и сохраняется в папку docs/logs/.**
- **Формат имени файла лога** (порядок частей):
  1. **Название задания** — имя файла из поля `file` манифеста, без расширения `.md` (например `TASK-017-fe-ui-api2-spec-and-update`).
  2. **Дата** — дата и время (например `2026-01-30T12-00-00`).
  3. **Шаг** — шаг выполнения (например `attempt-1`; для actualize/stop может быть пусто или одно значение).
  4. **Агент** — имя агента (например `exec`, `verify`, `actualize`, `stop`).
  5. Окончание — `-log.md`.
- **Примеры имён файлов:** `TASK-017-fe-ui-api2-spec-and-update-2026-01-30T12-00-00-attempt-1-exec-log.md`, `TASK-017-fe-ui-api2-spec-and-update-2026-01-30T12-05-00-attempt-1-verify-log.md`, `TASK-017-fe-ui-api2-spec-and-update-2026-01-30T12-10-00-actualize-log.md`, `TASK-017-fe-ui-api2-spec-and-update-2026-01-30T12-15-00-stop-log.md`.
- Папка `docs/logs/` создаётся скриптом при необходимости.
- **При остановке скрипта** (например, после 5 неудачных попыток по задаче) в лог записывается **подробная причина остановки**: id задачи, причина (задание не решено за 5 попыток), при необходимости — краткая сводка по попыткам или ссылки на логи проверок. Файл лога остановки сохраняется в `docs/logs/` с тем же форматом имени: `{названиеЗадания}-{датаВремя}-stop-log.md`.

### Проверка и доработки в документе задачи

- После каждой попытки выполнения агент проверки определяет: задание выполнено верно или нет.
- В **конец документа задачи** (файл из манифеста, например `docs/tasks/TASK-017-fe-ui-api2-spec-and-update.md`) записывается блок с:
  - датой/временем проверки;
  - номером попытки;
  - статусом проверки (успех / неуспех);
  - перечнем необходимых доработок и исправлений (если неуспех).
- Формат блока (markdown-секция, JSON в комментарии и т.п.) — на усмотрение реализации.

---

## Алгоритм работы скрипта (псевдокод)

1. Прочитать `docs/tasks/tasks-manifest.json`.
2. Отфильтровать задачи к выполнению (например, только со статусом `planned` или по списку id; критерий — в конфиге/параметрах скрипта).
3. Для каждой задачи по порядку:
   - Создать ветку для задания (если ещё не создана).
   - `attempt := 1`.
   - Цикл пока `attempt <= 5`:
     - Запустить агента выполнения для текущей задачи; логировать вывод в `docs/logs/{названиеЗадания}-{датаВремя}-attempt-{attempt}-exec-log.md`.
     - Сделать коммит после агента выполнения.
     - Запустить агента проверки; логировать вывод в `docs/logs/{названиеЗадания}-{датаВремя}-attempt-{attempt}-verify-log.md`.
     - Агент проверки записывает в конец документа задачи: статус проверки и доработки.
     - Сделать коммит после агента проверки (в т.ч. изменения в документе задачи).
     - Если проверка = «задание решено верно» → выйти из цикла.
     - Иначе `attempt += 1`; если `attempt > 5` → записать в лог подробную причину остановки (id задачи, причина, сводка по попыткам); выполнить push текущей ветки; остановить скрипт, выйти.
   - После успешной проверки (перед переходом к следующей задаче):
     - Запустить агента актуализации для текущей задачи; логировать вывод в `docs/logs/{названиеЗадания}-{датаВремя}-actualize-log.md`.
     - Агент актуализирует состояние задачи (документ задачи) и манифеста (status, completedDate, branch и т.д.).
     - Сделать коммит после агента актуализации.
     - Выполнить push текущей ветки в удалённый репозиторий.
     - Перейти к следующей задаче.
4. Конец.

---

## Входные данные и конфигурация

- **Источник списка заданий:** `docs/tasks/tasks-manifest.json` (структура: массив объектов с полями `id`, `title`, `status`, `file` и т.д.).
- **Документ задачи:** для каждой задачи — файл из поля `file` (путь относительно корня репозитория или от папки `docs/tasks/`), например `docs/tasks/TASK-017-fe-ui-api2-spec-and-update.md`.
- **Критерий «какие задачи запускать»:** только задачи со статусом `planned` или явный список id в аргументах/конфиге скрипта — на усмотрение реализации.
- **Агент выполнения:** **агент IDE Cursor** (Cursor agent). Скрипт должен уметь запускать выполнение задания через Cursor (CLI, API Cursor или иной поддерживаемый способ) в режиме без участия пользователя.
- **Агенты проверки и актуализации:** способ запуска (тот же Cursor, отдельный скрипт/LLM, API) задаётся в конфиге или переменных окружения.

---

## Требования к реализации

1. **Язык/среда:** скрипт может быть на Node.js, Python, Bash или другом — по усмотрению команды; важно соблюдение алгоритма и требований выше.
2. **Конфиг/параметры:** возможность задать: путь к манифесту, папку логов, шаблон ветки, максимум попыток, способ запуска агентов (выполнения, проверки, актуализации) или путь к обёрткам.
3. **Идемпотентность/безопасность:** при повторном запуске скрипта не ломать уже выполненные задачи (учитывать статус в манифесте или флаг «задание уже проверено»).
4. **Логи:** кроме логов в `docs/logs/`, желательно выводить краткий прогресс в stdout (какая задача, какая попытка, результат проверки).

---

## Автономный (ночной) запуск

Скрипт рассчитан на **запуск без участия пользователя**, в том числе по расписанию (например, ночью). Необходимо обеспечить следующее.

- **Без интерактива:** скрипт не должен запрашивать ввод с клавиатуры; все параметры задаются конфигом, переменными окружения или аргументами командной строки.
- **Планировщик:** способ запуска по расписанию (cron, Windows Task Scheduler, CI pipeline и т.п.) не фиксируется в задаче; скрипт должен быть готов к однократному запуску из планировщика (запустили — отработал до конца или до остановки по правилам).
- **Окружение к моменту запуска:** репозиторий в состоянии, пригодном для работы (актуальная базовая ветка при необходимости — pull; учётные данные git для push доступны без запроса пароля: SSH-ключ, токен и т.п.); Cursor установлен и доступен для вызова агента (или настроен headless/серверный режим, если применимо).
- **Восстановление после сбоя:** при падении скрипта (не из-за 5 неудач по задаче, а из-за ошибки окружения, таймаута и т.п.) при следующем запуске не ломать уже выполненные задачи — учитывать статус в манифесте и при необходимости продолжать с последней незавершённой задачи (см. идемпотентность).
- **Таймауты (опционально):** при необходимости задать максимальное время на одну попытку выполнения или на одну задачу, чтобы ночной прогон не зависал бесконечно; поведение при срабатывании таймаута (считать попытку неудачной, записать в лог, перейти к следующей попытке или остановке) — в конфиге.
- **Уведомление по завершении (опционально):** при желании — отправка краткого отчёта по завершении прогона (успех, на какой задаче остановились, ссылка на лог остановки) в чат, почту или лог-файл сводки; способ настраивается отдельно.

---

## Критерии приёмки

- [ ] Скрипт читает задания из `docs/tasks/tasks-manifest.json` и выполняет их последовательно.
- [ ] Для каждой задачи создаётся отдельная ветка; каждая задача выполняется в своей ветке.
- [ ] На каждую задачу не более 5 попыток; после каждой попытки запускается агент проверки.
- [ ] После работы агента выполнения, агента проверки и агента актуализации выполняется коммит.
- [ ] Агент проверки записывает в конец документа задачи статус проверки и перечень доработок (при неуспехе).
- [ ] При успешной проверке перед переходом к следующему заданию запускается агент актуализации; он обновляет состояние задачи (документ) и манифеста (status, completedDate, branch); после него — коммит.
- [ ] После успешной проверки и работы агента актуализации выполняется push текущей ветки; затем скрипт переходит к следующему заданию; при неудаче за 5 попыток выполняется push, затем скрипт останавливается.
- [ ] По завершении работы над заданием (успешное или нет) выполняется push текущей ветки в удалённый репозиторий.
- [ ] При остановке скрипта (в т.ч. после 5 неудачных попыток) в лог записывается подробная причина остановки (id задачи, причина, сводка по попыткам); файл лога сохраняется в `docs/logs/`; перед выходом выполняется push.
- [ ] Логи работы агентов (в т.ч. актуализации) сохраняются в `docs/logs/`; имя файла: название задания → дата → шаг → агент → `-log.md`.
- [ ] Папка `docs/logs/` создаётся при необходимости.
- [ ] Способ запуска агентов (выполнения, проверки, актуализации) описан в README или конфиге скрипта.
- [ ] Агент выполнения — агент IDE Cursor; скрипт умеет запускать его в режиме без интерактивного ввода (для ночного/автономного запуска).
- [ ] Скрипт готов к автономному запуску: не требует ввода с клавиатуры; параметры задаются конфигом/переменными окружения/аргументами.
- [ ] При повторном запуске после сбоя уже выполненные задачи не перезапускаются (учёт статуса в манифесте или эквивалент).

---

## Вне границ задачи

- Реализация самих «агента проверки» и «агента актуализации» (их внутренняя логика, промпты, вызов LLM) может быть отдельной задачей или частью текущей — по согласованию. В данной задаче достаточно интерфейса запуска (команда/API) и формата логов и записи в документ задачи и манифест.
- Агент выполнения — **агент Cursor IDE**; конкретный способ его вызова в headless/ночном режиме (Cursor CLI, API, если доступны) уточняется при реализации; при отсутствии подходящего API документировать ограничение или рассмотреть альтернативы.

---

## Уточнения, необходимые для реализации

Ниже перечислены вопросы, по которым нужно принять решение до или в ходе реализации. Ответы можно зафиксировать в этой задаче или в отдельном конфиге/README скрипта.

### 1. Запуск агентов

| № | Вопрос | Варианты / комментарий |
|---|--------|-------------------------|
| 1.1 | Как именно запускается агент выполнения (Cursor)? | Агент выполнения — **агент IDE Cursor**. Запуск: Cursor CLI (если есть), API Cursor для вызова агента в headless/фоновом режиме, или иной поддерживаемый способ без открытия UI. Нужно зафиксировать интерфейс: команда/API + аргументы (путь к файлу задачи, номер попытки, путь к документу с доработками и т.п.). |
| 1.2 | Передаём ли агенту выполнения текст «доработок» из предыдущей попытки (блок из конца документа задачи)? | Да — агент должен учитывать доработки при повторной попытке. Нет — агент каждый раз читает только описание задачи. |
| 1.3 | Что передаётся агенту проверки на вход? | Путь к документу задачи, путь к корню репозитория, список изменённых файлов за попытку, что ещё? |
| 1.4 | Кто записывает блок проверки в конец документа задачи — скрипт или агент проверки? | Агент проверки сам дописывает в файл. Или агент возвращает структурированный результат (статус + доработки), а скрипт записывает блок в документ. |
| 1.5 | Как запускается агент актуализации? | Тот же интерфейс, что и для агентов выполнения/проверки (команда/API с аргументами: taskId, путь к документу задачи, путь к манифесту, текущая ветка и т.п.)? |
| 1.6 | Что именно делает агент актуализации? | Обновляет в документе задачи статус (например «Выполнено»), дату завершения; в манифесте — поля `status`, `completedDate`, `branch` для данной задачи. Нужно ли зафиксировать список полей и формат в задаче? |

### 2. Ветки и база

| № | Вопрос | Варианты / комментарий |
|---|--------|-------------------------|
| 2.1 | От какой ветки создаётся ветка для задания? | main, develop, текущая ветка на момент запуска скрипта, параметр конфига? |
| 2.2 | Если ветка для задачи уже существует (например, от предыдущего запуска), что делаем? | Переключаемся на неё и продолжаем попытки. Или создаём новую от актуальной базы. Или отказ/ошибка. |
| 2.3 | Имя ветки: откуда брать? | В манифесте у planned-задач часто `branch: null`. Шаблон, например `feature/{id}-{slug}` (slug из названия или файла)? Нужно ли обновлять поле `branch` в манифесте после создания ветки? |
| 2.4 | Push: в какой remote и какую ветку пушить? | По умолчанию `origin` и текущая ветка (текущий branch). Нужна ли настройка remote/ветки в конфиге? Что делать при ошибке push (повтор, остановка, запись в лог)? |

### 3. Коммиты

| № | Вопрос | Варианты / комментарий |
|---|--------|-------------------------|
| 3.1 | Формат сообщения коммита? | Например: `[TASK-017] attempt 1: exec`, `[TASK-017] attempt 1: verify` — зафиксировать или оставить на усмотрение? |
| 3.2 | Коммитить ли сами файлы логов из `docs/logs/`? | Да — полная история в репозитории. Нет — логи только локально/в артефактах; в репо не коммитить (размер, шум). |
| 3.3 | Если за шаг не было изменений (агент ничего не изменил) — делать пустой коммит или пропускать коммит? | Пустой коммит для единообразия истории. Или коммит только при наличии изменений. |

### 4. Документ задачи и блок проверки

| № | Вопрос | Варианты / комментарий |
|---|--------|-------------------------|
| 4.1 | Точный формат блока проверки в конце документа (markdown)? | Заголовок уровня (например `## Проверка попыток`), подсекции по попыткам с полями: дата/время, номер попытки, статус (успех/неуспех), доработки. Имеет смысл привести пример в задаче, чтобы скрипт и агент проверки использовали один формат. |
| 4.2 | Куда именно вставлять блок — буквально в конец файла или перед последней секцией (например перед «Связанные артефакты»)? | В конец файла. Или всегда перед секцией «Проверка попыток» / перед определённым заголовком. |
| 4.3 | Нужно ли после успешной проверки обновлять манифест (status → completed, completedDate, branch)? | Да — это делает **агент актуализации** (перед переходом к следующему заданию). Скрипт только запускает агента; агент правит документ задачи и манифест. |

### 5. Какие задачи запускать

| № | Вопрос | Варианты / комментарий |
|---|--------|-------------------------|
| 5.1 | Какие задачи брать из манифеста? | Только со статусом `planned`. Или явный список id в аргументах/конфиге. Или оба варианта (по умолчанию planned, опционально — список id). |
| 5.2 | Нужна ли возможность «продолжить с задачи X»? | Параметр «начать с TASK-018» (все предыдущие пропустить). Или всегда с первой отфильтрованной. |
| 5.3 | Уже выполненные (status = completed) — всегда пропускать? | Да. Или опция «перезапустить задачу» для перепроверки. |

### 6. Логи

| № | Вопрос | Варианты / комментарий |
|---|--------|-------------------------|
| 6.1 | Полный формат имени файла лога? | **Зафиксировано:** название задания → дата → шаг → агент → `-log.md`. Пример: `TASK-017-fe-ui-api2-spec-and-update-2026-01-30T12-00-00-attempt-1-exec-log.md`. |
| 6.2 | Что попадает в лог-файл? | Только stdout/stderr агента. Или ещё метаданные: время старта/завершения, exit code, taskId, attempt. |
| 6.3 | Путь к папке логов: всегда `docs/logs/` или настраиваемый (конфиг/аргумент)? | Жёстко `docs/logs/`. Или конфигурируемо, по умолчанию `docs/logs/`. |

### 7. Ошибки и остановка

| № | Вопрос | Варианты / комментарий |
|---|--------|-------------------------|
| 7.1 | Если агент выполнения упал с ошибкой (exception, non-zero exit) — это одна попытка? | Да — считаем попыткой, запускаем агента проверки (или записываем «попытка не завершена») и коммит. Или не считаем попыткой, повторяем выполнение без проверки. |
| 7.2 | После остановки (5 неудач): записывать ли в документ задачи итоговый блок «не решено за 5 попыток» и делать коммит? | Да — для истории. Нет — только остановка скрипта. |
| 7.3 | Что включать в лог причины остановки? | Id задачи, причина (не решено за 5 попыток), дата/время остановки, при необходимости — сводка по попыткам (номер попытки, результат проверки, кратко доработки), пути к логам агентов (exec/verify) по этой задаче. Имя файла: `{названиеЗадания}-{датаВремя}-stop-log.md`. |
| 7.4 | Нужен ли режим dry-run? | Вывести список задач и веток без запуска агентов и без коммитов. |

### 8. Окружение и манифест

| № | Вопрос | Варианты / комментарий |
|---|--------|-------------------------|
| 8.1 | Где выполняется скрипт? | **Сценарий: ночной/автономный запуск** (например, на той же машине, где установлен Cursor; или в среде, где доступен Cursor CLI/API). Машина включена по расписанию; git настроен на push без интерактива (SSH/key, токен). |
| 8.2 | Путь к манифесту: всегда `docs/tasks/tasks-manifest.json` от корня репозитория? | В монорепо корень может быть разный (весь репо или подпапка приложения). Нужно ли явно задавать «корень репо» и путь к манифесту относительно него? |
| 8.3 | Cursor в ночном режиме: как запускать агента без открытого окна? | Требуется способ вызова Cursor agent без интерактива (CLI, API, headless). Если такого нет — документировать ограничение или альтернативу (например, отдельный сервис с LLM для проверки/актуализации). |

### 9. Автономный запуск и сбои

| № | Вопрос | Варианты / комментарий |
|---|--------|-------------------------|
| 9.1 | Перед ночным запуском: делать ли pull базовой ветки? | Да — скрипт в начале делает pull (например main/develop), затем создаёт ветки для задач. Нет — предполагаем, что репо уже обновлён. |
| 9.2 | Таймаут на одну попытку или на одну задачу? | Ограничить время выполнения одной попытки (например 30 мин), чтобы ночной прогон не зависал. При таймауте — считать попытку неудачной, записать в лог, следующая попытка или остановка. |
| 9.3 | Уведомление по завершении прогона? | Опционально: при остановке (успех всех запланированных задач или неудача за 5 попыток) отправить краткий отчёт (файл, чат, почта) — что выполнено, на чём остановились, ссылка на лог. |

---

## Связанные артефакты

- Манифест заданий: `docs/tasks/tasks-manifest.json`
- Документы заданий: `docs/tasks/TASK-*.md`
- Папка логов: `docs/logs/` (создаётся скриптом)
- Агент выполнения: **Cursor IDE agent** (интеграция через CLI/API Cursor для автономного запуска)
