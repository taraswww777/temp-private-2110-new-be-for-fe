# TASK-016: Доработка GET /api/v1/report-6406/storage/volume — массив хранилищ и упрощённый DTO

**Статус**: открыто  
**Ветка**: `feature/TASK-016-storage-volume-array`

**Связь**: Замечания по Swagger/API после доработок (тёмная тема, скрипты, тесты).

---

## Цель

Изменить эндпоинт **GET /api/v1/report-6406/storage/volume** так, чтобы ответ представлял собой массив сущностей (корзина 1, корзина 2, ТФР и т.д.), с человекочитаемыми полями и полем `id` для использования в качестве уникального ключа при отрисовке через `map` в JSX.

---

## Требования к ответу

### 1. Ответ — массив сущностей

- **Было**: один объект с объёмом «общего» хранилища.
- **Стало**: массив объектов, по одному на каждое хранилище (корзина 1, корзина 2, ТФР и т.д.).

Тип ответа: массив DTO (см. ниже).

### 2. Поле с именем хранилища

В каждую сущность добавить поле с именем хранилища (например, «Корзина 1», «Корзина 2», «ТФР»), чтобы на фронте можно было различать и подписывать блоки.

### 3. Только человекочитаемые поля и процент заполнения

В каждой сущности оставить только:

| Поле         | Тип     | Описание |
|-------------|---------|----------|
| `totalHuman` | string | Общий объём хранилища в человекочитаемом формате (например, `"1.00 TB"`). |
| `freeHuman`  | string | Свободный объём в человекочитаемом формате (например, `"535.72 GB"`). |
| `percent`    | number | Процент заполнения (0–100). |

Поля в байтах (`totalBytes`, `usedBytes`, `freeBytes`), `usedHuman`, `warning` и т.п. из текущего DTO в ответе этого эндпоинта не возвращать (при необходимости их можно оставить во внутренней логике/сервисе).

### 4. Поле `id` для уникального ключа

В каждую сущность добавить поле **`id`** (string или number), уникальное в рамках ответа, чтобы использовать его как `key` при рендере списка хранилищ через `map` в JSX (например, `key={item.id}`).

---

## Целевая схема элемента массива (StorageVolumeItemDto)

```ts
{
  id: string;           // уникальный идентификатор хранилища для key в JSX
  name: string;          // имя хранилища (например, "Корзина 1", "ТФР")
  totalHuman: string;   // общий объём, человекочитаемый
  freeHuman: string;    // свободный объём, человекочитаемый
  percent: number;      // процент заполнения (0–100)
}
```

Тип ответа эндпоинта: массив таких объектов, например:

```json
[
  { "id": "bucket-1", "name": "Корзина 1", "totalHuman": "1.00 TB", "freeHuman": "800.00 GB", "percent": 21.5 },
  { "id": "bucket-2", "name": "Корзина 2", "totalHuman": "500.00 GB", "freeHuman": "200.00 GB", "percent": 60 },
  { "id": "tfr", "name": "ТФР", "totalHuman": "2.00 TB", "freeHuman": "1.50 TB", "percent": 25 }
]
```

---

## Задачи для реализации

1. **Схемы (Zod + OpenAPI)**  
   - Ввести схему элемента массива (например, `StorageVolumeItemSchema`) с полями: `id`, `name`, `totalHuman`, `freeHuman`, `percent`.  
   - Схему ответа GET /storage/volume заменить на массив этих элементов (и зарегистрировать в OpenAPI/компонентах).

2. **Сервис**  
   - Адаптировать `StorageService.getStorageVolume()` (или ввести метод, возвращающий массив): для каждого «хранилища» (корзина/ТФР) формировать один элемент с `id`, `name`, `totalHuman`, `freeHuman`, `percent`.  
   - Пока хранилище одно — возвращать массив из одного элемента; при появлении нескольких корзин/ТФР — возвращать по элементу на каждое.

3. **Роут**  
   - GET /api/v1/report-6406/storage/volume возвращает массив описанных DTO, описание и схема ответа в Swagger обновлены.

4. **Обратная совместимость**  
   - Контракт меняется (объект → массив), поэтому считается breaking change; клиенты (в т.ч. фронт) должны перейти на новый формат.

5. **Проверка использования**  
   - Убедиться, что все места, где вызывается `getStorageVolume()` или читается ответ эндпоинта (в т.ч. проверка «достаточно ли места» при создании задания), обновлены под массив (например, проверка по нужному хранилищу по `id` или первому элементу — по продукту).

---

## Критерии приёмки

- GET /api/v1/report-6406/storage/volume возвращает **массив** объектов.
- Каждый объект содержит поля: **id**, **name**, **totalHuman**, **freeHuman**, **percent** (и только их в ответе).
- В Swagger описание и схема ответа соответствуют новой структуре.
- На фронте можно использовать `item.id` как уникальный `key` при рендере списка хранилищ через `map` в JSX.
